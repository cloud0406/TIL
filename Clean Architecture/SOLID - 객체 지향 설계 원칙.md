# SOLID - 객체 지향 설계 원칙

## SOLID란?

- 클린 아키텍처의 바탕에는 SOLID라는 객체 지향 설계 원칙이 배경으로 있다.
- SOLID 적용 시 유지 보수와 확장이 쉬운 시스템을 만들 수 있다.
- SOLID는 각각의 개념이 분리되어 동작하는 것이 아닌 여러 개념이 함께 조합되어 작동할 때 더 나은 구조를 갖게 된다.

### SRP(Single Responsibility Principle : 단일 책임 원칙)

- 한 클래스는 하나의 책임만을 가져야 한다.
- 즉 클래스를 변경하는 이유는 오직 한 가지 뿐이어야 한다. (여기서 클래스는 객체지향언어에서 말하는 클래스 자체가 아닌 함수, 오브젝트 등 최소 동작의 단위)
- 코드를 작성하다 보면 한 클래스가 너무 비대해지는 경우가 발생하는데, 너무 비대한 클래스는 다른 클래스와의 의존성이 증가하게 되므로 변경 시 비용이 크며, 클래스를 크기가 작은 책임을 가지도록 작성해야 유연하게 대처 가능하다.

### OCP(Open-Closed Principle : 개방-폐쇄 원칙)

- 소프트웨어 요소는 확장에는 열러 있지만 변경에는 닫혀 있어야 함
- 소프트웨어의 요구사항이 추가되었다고 기존의 소스 코드를 계속 고쳐야 한다면 점점 유지 보수가 힘들게 됨. 따라서, 기능의 추가가 기존 코드에 영향을 끼치지 않는 구조가 필요
- OCP는 이를 인터페이스를 활용하여 쉽게 달성
- 필요한 기능이 있다면 구현체에 의존하는 것이 아닌 인터페이스에 의존해야 함
- 추가로 필요한 기능이 있을 경우, 인터페이스를 추가하여 해결

### LSP(Liskov Substitution Principle : 리스코프 치환 원칙)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 상속 관계에서 자식 클래스의 인스턴스를 부모 클래스로 선언된 함수의 인자로 전달 가능 (클래스 뿐 아니라 인터페이스를 구현한 클래스에서도 마찬가지)
- 실제 동작하는 인스턴스는 인터페이스가 제공하는 기능을 구현한 객체지만, 인터페이스를 사용하는 다른 객체에 전달 가능
- 즉, 실제 구현체인 자식 인스턴스는 언제든 부모 혹은 인터페이스가 제공해야 하는 기능을 제공하는 다른 구현체로 변경할 수 있음

### ISP(Interface Segregation Principle : 인터페이스 분리 원칙)

- 범용 인터페이스 하나보단 특정 클라이언트를 위한 인터페이스 여러 개가 좋음
- 하나의 인터페이스에 의존하게 되면 인터페이스의 기능이 추가될 때 인터페이스를 구현하는 모든 클래스를 수정해야 함
- 따라서 인터페이스를 기능별로 쪼개 특정 클라이언트용 인터페이스로 모아 사용하는 것이 변경에 대해서 의존성을 낮추고 유연하게 대처할 수 있음

### DIP(Dependency Inversion Principle : 의존성 역전 원칙)

- 프로그래머는 구체화에 의존하면 안되고 추상화에 의존해야 함
- 클린 아키텍처를 구현하기 위해서 의존성 역전이 발생할 수 있으며 이를 해소하기 위해 DI(의존성 역전)을 이용해야 함 (DI는 보통 프레임워크에서 제공하거나 DI를 구현할 수 있는 라이브러리를 이용)

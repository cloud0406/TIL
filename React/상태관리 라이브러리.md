## 상태관리 라이브러리의 필요성

- 부모가 가지고 있는 State 데이터를 **최하위에 있는 자식 컴포넌트에 props로 넘겨**주려고 하려면중간 중간에 있는 모든 자식 컴포넌트들에게 사용하지 않는 props를 추가해 넘겨줘야 함 → Props Drilling
- 컴포넌트의 목적은 독립과 재사용성이지만, 중간 컴포넌트들로 인해 오히려 상위 컴포넌트와 하위 컴포넌트가 더 굳게 결속됨
- 이를 해결하기 위해 기존의 계층 구조가 아닌 비즈니스 로직을 컴포넌트에서 분리해 별도로 관리하게 되었으며 이 개념이 ‘상태관리 (state management)’

## Mobx

- Redux보다 사용률이 떨어짐
  - Mobx는 store가 여러개가 될 수 있는데, 이는 분리가 용이해 편리할 수 있지만 상태 변경 시 다수의 store가 영향을 받을 수 있음.
  - Redux와 다르게 store의 데이터를 action 발행 없이 업데이트 할 수 있는데 구현은 쉽지만 유지보수 측면에서 문제가 야기될 수 있음
  - 보통 유지보수 및 확장성을 크게 신경쓰지 않는 작은 프로젝트에서 사용

## Context API

- 리액트가 자체적으로 가지고 있으며 정적인 데이터 위주로 처리하거나 업데이트가 자주 발생하지 않을 때 사용하기 적합
- context api 에서 상태값을 변경하면, provider 로 감싼 모든 자식 컴포넌트들이 리렌더링되기 때문에 복잡한 업데이트를 처리 할 때에는 비효율적 (결론적으로 context api 는 상태관리 도구로 사용하면 props drilling 을 회피한다는 장점보다 잃는 것이 더 많다.) → 이를 보완하기 위해 나온게 Recoil

## Redux

- 데이터 흐름이 단방향으로 흐르는 구조
- action, reducer, selector, store를 세팅하는 보일러플레이트 코드는 유지보수라는 장점을 가지고 있지만, 상태의 개수가 적더라도 보일러 플레이트 코드가 크다는 단점 → Redux를 사용하기 꺼려하는 가장 큰 이유
- store에 모든 상태를 저장하는 중앙집중방식 (store는 외부 요소이기 때문에 리액트 내부에 접근 불가)
- **Store**
  - 저장소, 즉 전역상태를 저장하는 공간이다.
  - 자바스크립트 객체 형태로 저장되어 있으며, 오직 Reducer를 통해서만 접근할 수 있다.
  - 보통은 최상단의 index.js에 정의한다. 여러개의 Context를 만들 수 있는 Context API와는 다르게 Redux에서 Store는 1개만 존재할 수 있다.
    ```tsx
    import { createStore } from "redux";
    import rootReducer from "./reducer";

    const store = createStore(rootReducer);

    export default store;
    ```
- **Action**
  - Reducer에게 보내는 Store에 대한 행동을 정의하는 자바스크립트 객체이다.
  - Action을 Reducer에게 전달하기 위해서는 dispatch 메소드를 사용해야한다.
  - dispatch는 Store의 내장 함수 중 하나인데, 액션 객체를 넘겨줘서 상태를 업데이트한다.
  - 이벤트를 일어나게하는 이벤트 트리거의 역할을 한다.
    ```tsx
    // 다음과 같이 타입 지정
    ex) {type: 'increment'} , {type: 'decrement', payload: text}
    ```
    ```tsx
    // dispatch 메소드 사용
    return (
       <button onClick={()=>{ props.dispatch({ type: 'increment'}) }}>+</button>
       <button onClick={()=>{ props.dispatch({ type: 'decrement'}) }}>-</button>
    )
    ```
- **Reducer**
  - 이전 상태와 액션을 받아, 다음 상태를 반환하는 역할을 하는 **순수 함수**(다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수)이다.
  - Reducer를 통해서만 전역 상태를 변경하고 업데이트할 수 있다.
  - 어떤 액션이 들어오는지 그 유형에 따라 이벤트를 처리하는 이벤트 리스너라고 볼 수 있다.
  - 여기서 중요한 점은, 이전 상태를 변경한다는 점이 아니라, 새로운 상태 객체를 생성해서 반환해야한다는 사실이다.
    ```tsx
    const initialState = {
      count: 0,
    };

    // initialState를 통해 초기 state를 저장
    export default function countingReducer(state = initialState, action) {
      // action.type을 보고 reducer를 실행
      switch (action.type) {
        case "push": {
          return {
            ...state,
            count: state.count + 1,
          };
        }
        default:
          return state;
      }
    }
    ```
- 비동기 데이터 처리를 하기 위해선 Redux-saga와 같은 별도 라이브러리 사용이 필요함. (서버 데이터를 받아와 관리하기 위해 필요)
- 하나의 store만 가지고, 하나의 객체 트리를 가지기 때문에 디버깅이 용이함.

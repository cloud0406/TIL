## 상태관리 라이브러리의 필요성

- 부모가 가지고 있는 State 데이터를 **최하위에 있는 자식 컴포넌트에 props로 넘겨**주려고 하려면중간 중간에 있는 모든 자식 컴포넌트들에게 사용하지 않는 props를 추가해 넘겨줘야 함 → Props Drilling
- 컴포넌트의 목적은 독립과 재사용성이지만, 중간 컴포넌트들로 인해 오히려 상위 컴포넌트와 하위 컴포넌트가 더 굳게 결속됨
- 이를 해결하기 위해 기존의 계층 구조가 아닌 비즈니스 로직을 컴포넌트에서 분리해 별도로 관리하게 되었으며 이 개념이 ‘상태관리 (state management)’

## Redux

- 데이터 흐름이 단방향으로 흐르는 구조
- action, reducer, selector, store를 세팅하는 보일러플레이트 코드는 유지보수라는 장점을 가지고 있지만, 상태의 개수가 적더라도 보일러 플레이트 코드가 크다는 단점 → Redux를 사용하기 꺼려하는 가장 큰 이유
- store에 모든 상태를 저장하는 중앙집중방식 (store는 외부 요소이기 때문에 리액트 내부에 접근 불가)
- **Store**

  - 저장소, 즉 전역상태를 저장하는 공간이다.
  - 자바스크립트 객체 형태로 저장되어 있으며, 오직 Reducer를 통해서만 접근할 수 있다.
  - 보통은 최상단의 index.js에 정의한다. 여러개의 Context를 만들 수 있는 Context API와는 다르게 Redux에서 Store는 1개만 존재할 수 있다.

    ```tsx
    import { createStore } from "redux";
    import rootReducer from "./reducer";

    const store = createStore(rootReducer);

    export default store;
    ```

- **Action**
  - Reducer에게 보내는 Store에 대한 행동을 정의하는 자바스크립트 객체이다.
  - Action을 Reducer에게 전달하기 위해서는 dispatch 메소드를 사용해야한다.
  - dispatch는 Store의 내장 함수 중 하나인데, 액션 객체를 넘겨줘서 상태를 업데이트한다.
  - 이벤트를 일어나게하는 이벤트 트리거의 역할을 한다.
    ```tsx
    // 다음과 같이 타입 지정
    ex) {type: 'increment'} , {type: 'decrement', payload: text}
    ```
    ```tsx
    // dispatch 메소드 사용
    return (
       <button onClick={()=>{ props.dispatch({ type: 'increment'}) }}>+</button>
       <button onClick={()=>{ props.dispatch({ type: 'decrement'}) }}>-</button>
    )
    ```
- **Reducer**

  - 이전 상태와 액션을 받아, 다음 상태를 반환하는 역할을 하는 **순수 함수**(다른 외부의 상태를 변경하지 않으면서도, 어떤 동일한 인자에 대해 항상 동일한 값을 리턴하는 함수)이다.
  - Reducer를 통해서만 전역 상태를 변경하고 업데이트할 수 있다.
  - 어떤 액션이 들어오는지 그 유형에 따라 이벤트를 처리하는 이벤트 리스너라고 볼 수 있다.
  - 여기서 중요한 점은, 이전 상태를 변경한다는 점이 아니라, 새로운 상태 객체를 생성해서 반환해야한다는 사실이다.

    ```tsx
    const initialState = {
      count: 0,
    };

    // initialState를 통해 초기 state를 저장
    export default function countingReducer(state = initialState, action) {
      // action.type을 보고 reducer를 실행
      switch (action.type) {
        case "push": {
          return {
            ...state,
            count: state.count + 1,
          };
        }
        default:
          return state;
      }
    }
    ```

- 비동기 데이터 처리를 하기 위해선 Redux-saga와 같은 별도 라이브러리 사용이 필요함. (서버 데이터를 받아와 관리하기 위해 필요)
- 하나의 store만 가지고, 하나의 객체 트리를 가지기 때문에 디버깅이 용이함.

## Mobx

- Redux보다 사용률이 떨어짐
  - Mobx는 store가 여러개가 될 수 있는데, 이는 분리가 용이해 편리할 수 있지만 상태 변경 시 다수의 store가 영향을 받을 수 있음.
  - Redux와 다르게 store의 데이터를 action 발행 없이 업데이트 할 수 있는데 구현은 쉽지만 유지보수 측면에서 문제가 야기될 수 있음
  - 보통 유지보수 및 확장성을 크게 신경쓰지 않는 작은 프로젝트에서 사용

## Context API

- 리액트가 자체적으로 가지고 있으며 정적인 데이터 위주로 처리하거나 업데이트가 자주 발생하지 않을 때 사용하기 적합
- context api 에서 상태값을 변경하면, provider 로 감싼 모든 자식 컴포넌트들이 리렌더링되기 때문에 복잡한 업데이트를 처리 할 때에는 비효율적 (결론적으로 context api 는 상태관리 도구로 사용하면 props drilling 을 회피한다는 장점보다 잃는 것이 더 많다.) → 이를 보완하기 위해 나온게 Recoil

## Recoil (토스)

```tsx
npm install recoil
```

- 페이스북에서 나온 라이브러리로 Atom과 Selector로 이루어짐
- recoil 상태를 사용하는 컴포넌트는 부모 트리 어딘가에 나타나는 `RecoilRoot`가 필요하다. 루트 컴포넌트 (App.js)가 `RecoilRoot`를 넣기에 가장 좋은 장소다.
  ```tsx
  // App.js

  import { RecoilRoot } from "recoil"; // RecoilRoot가 반드시 필요
  import FontButton from "./FontButton";
  import Text from "./Text";

  function App() {
    return (
      <div className="App">
        <RecoilRoot>
          {" "}
          // 컴포넌트들을 RecoilRoot로 감싸줌
          <FontButton />
          <Text />
        </RecoilRoot>
      </div>
    );
  }

  export default App;
  ```
- Atom은 상태의 단위로, 유니크한 키값으로 구분하며 어떤 컴포넌트에서나 읽고 쓸 수 있다.
- Atom이 업데이트되면 각각의 구독된 컴포넌트들은 모두 새로운 값을 반영하여 다시 렌더링됨 (atom의 값을 읽는 컴포넌트들은 암묵적으로 atom을 구독한다.)
  ```tsx
  // atom 함수를 통해 생성
  export const fontSizeState = atom({
    key: "fontSizeState",
    default: 14,
  });
  ```
- 컴포넌트에서 atom을 읽고 쓰기 위해선 useRecoilState라는 훅을 사용해야 함 (useState와 비슷하지만 상태가 컴포넌트 간에 공유될 수 있다는 차이가 있음)
  ```tsx
  import { fontSizeState } from "./state";

  // 버튼 클릭시, 글꼴 크기가 1만큼 증가하며, fontSizeState atom을 사용하는 밑에 Text 컴포넌트의 글꼴 크기도 같이 변경됨
  function FontButton() {
    const [fontSize, setFontSize] = useRecoilState(fontSizeState);
    return (
      <button
        onClick={() => setFontSize((size) => size + 1)}
        style={{ fontSize }}
      >
        Click to Enlarge
      </button>
    );
  }

  function Text() {
    const [fontSize, setFontSize] = useRecoilState(fontSizeState);
    return <p style={{ fontSize }}>This text will increase in size too.</p>;
  }
  ```
- Atom의 상태변화는 순수함수를 통해 일어나며 이를 Selector라 함
- Selector는 atom의 상태값을 동기 또는 비동기 방식을 통해 변환
- Selector는 비동기 처리 뿐만 아니라 데이터 **캐싱 기능**(selector를 통해 비동기 작업을 진행할 때 사용되는 atom에 자동으로 의존성이 걸리게 된다. 즉, atom의 값이 변경될 때 마다 selector가 변경되는데, atom의 값이 같으면 내부적으로 반환값을 메모이즈 하고 있어 캐싱된 값을 반환하게 된다.) 도 제공하기 때문에 비동기 데이터를 다루기에 용이
- 보일러플레이트가 없기 때문에 리액트 지역 상태로서 단순한 get/set 인터페이스로 상태를 공유할 수 있음
  ```tsx
  // selector 함수를 통해 생성
  export const charCountState = selector({
    key: "charCountState", // 유니크한 key값 지정
    get: ({ get }) => {
      const size = get(fontSizeState);

      return size;
    },
  });
  ```
- selector 함수로 생성된 값을 읽기 위해선 `useRecoilValue()`훅을 사용
  ```tsx
  import { charCountState } from "./state";

  function FontSizeText() {
    const count = useRecoilValue(charCountState);

    return <>Character Count: {count}</>;
  }
  ```
- 동시성 모드와 양립할 수 있는 가능성이 있음
- 상태를 분산적으로 둘 수 있기 때문에 **코드 스플리팅**(당장 사용하는 부분만 로딩, 현재 필요하지 않은 코드 부분은 따로 분리시켜 나중에 로드함으로서 로딩 시간을 개선하는 것)이 가능
- Recoil은 버전이 낮아 안정성의 측면에서 좋지 않을 수도 있음 → 업데이트가 그렇게 활발하게 이루어지지 않음
- REST API 사용할 경우
  - React-query
  - Tanstack-query (API로부터 데이터 불러오기, 저장, 자동화) + Recoil(미니 리덕스)
- GraphQL API 사용할 경우
  - Apollo-client + Recoil
